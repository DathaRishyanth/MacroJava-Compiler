// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import java.util.*;
import javax.swing.plaf.synth.SynthStyle;
import java.lang.reflect.Field;

public class TypeCheckerVisitor<R, A> implements GJVisitor<R, A> {

    String currentClass = null;
    String currentMethod = null;
    boolean lambdaActive = false;
    String expectedFunctionalType = null;

    HashMap<String, ClassInfo> symbolTable;

    private MethodInfo lookupMethodInfo(String className, String methodName) {
        String currentClassName = className;
        while (currentClassName != null) {
            ClassInfo ci = symbolTable.get(currentClassName);
            if (ci == null) {

                return null;
            }

            if (ci.methods != null && ci.methods.containsKey(methodName)) {

                return ci.methods.get(methodName);
            }

            currentClassName = ci.parent;
        }

        return null;
    }

    public boolean is_equal(String type1, String type2) {
        if (type1 == null || type2 == null) {
            return false;
        }

        String n1 = normalizeType(type1);
        String n2 = normalizeType(type2);

        if (n1.equals(n2)) {
            return true;
        }
        if (!symbolTable.containsKey(n1) || !symbolTable.containsKey(n2)) {
            return false;
        }

        String currentType = n1;
        while (currentType != null) {
            ClassInfo ci = symbolTable.get(currentType);
            if (ci == null || ci.parent == null) {
                break;
            }

            currentType = ci.parent;
            if (currentType.equals(n2)) {
                return true;
            }
        }

        return false;
    }

    private LambdaExpression extractLambda(Expression expr) {
        if (expr == null)
            return null;
        try {
            Object choice = expr.f0.choice;

            if (choice instanceof LambdaExpression)
                return (LambdaExpression) choice;

            if (choice instanceof PrimaryExpression) {
                PrimaryExpression pe = (PrimaryExpression) choice;
                Object pchoice = pe.f0.choice;

                if (pchoice instanceof BracketExpression) {
                    BracketExpression be = (BracketExpression) pchoice;
                    return extractLambda(be.f1);
                }

                return null;
            }
        } catch (Exception ignored) {
            System.out.println("Type error");
            System.exit(0);
        }
        return null;
    }

    private void checkLambdaArgument(LambdaExpression lamNode, String expectedFunctionType, A argu) {
        String[] expectedFunParts = parseFunctionType(expectedFunctionType);
        if (expectedFunParts == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        String expectedParamType = normalizeType(expectedFunParts[0]);
        String expectedBodyRetType = normalizeType(expectedFunParts[1]);

        String paramName = lamNode.f1.f0.tokenImage;
        MethodInfo mi = symbolTable.get(currentClass).methods.get(currentMethod);

        String old = mi.var_types.get(paramName);
        mi.var_types.put(paramName, expectedParamType);

        R bodyR = lamNode.f4.accept(this, argu);
        String resolvedBodyType = normalizeType(resolveTypeToken((String) bodyR));

        if (old == null)
            mi.var_types.remove(paramName);
        else
            mi.var_types.put(paramName, old);

        if (resolvedBodyType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!is_equal(resolvedBodyType, expectedBodyRetType)) {
            System.out.println("Type error");
            System.exit(0);
        }
    }

    private String normalizeType(String t) {
        if (t == null)
            return null;
        t = t.trim();

        if (parseFunctionType(t) != null)
            return t;

        if (t.endsWith("[]")) {
            String elem = t.substring(0, t.length() - 2);
            String normElem = normalizeType(elem);
            if (normElem == null)
                return null;
            return normElem + "[]";
        }

        if ("Integer".equals(t) || "int".equals(t))
            return "int";
        if ("Boolean".equals(t) || "boolean".equals(t))
            return "boolean";

        if (symbolTable.containsKey(t))
            return t;

        return t;
    }

    private String resolveTypeToken(String token) {
        if (token == null)
            return null;

        if ("this".equals(token))
            return currentClass;

        if ("int".equals(token) || "boolean".equals(token) || token.endsWith("[]"))
            return token;

        if (parseFunctionType(token) != null)
            return token;

        if (symbolTable.containsKey(token))
            return token;

        String vt = lookupVarType(token);
        if (vt != null)
            return normalizeType(vt);

        return null;
    }

    private String[] parseFunctionType(String s) {
        if (s == null)
            return null;
        String t = s.replaceAll("\\s+", "");
        if (!t.startsWith("Function<") || !t.endsWith(">"))
            return null;
        String inside = t.substring("Function<".length(), t.length() - 1);
        String[] parts = inside.split(",");
        if (parts.length != 2)
            return null;
        parts[0] = parts[0].trim();
        parts[1] = parts[1].trim();
        return parts;
    }

    private String resolveType(String token) {
        if (token == null) {
            System.out.println("null\n");
        }

        if (isPrimitiveType(token) || token.endsWith("[]") || token.equals("this") || symbolTable.containsKey(token)) {
            return token;
        }

        String vt = lookupVarType(token);
        if (vt == null) {
            System.out.println("Symbol not found");
        }
        return vt;
    }

    private boolean isPrimitiveType(String s) {
        return "int".equals(s) || "boolean".equals(s);
    }

    private String lookupVarType(String varName) {

        if (currentClass == null)
            return null;

        ClassInfo ci = symbolTable.get(currentClass);
        if (ci == null)
            return null;

        if (currentMethod != null && ci.methods != null && ci.methods.containsKey(currentMethod)) {
            MethodInfo mi = ci.methods.get(currentMethod);
            if (mi != null && mi.var_types != null && mi.var_types.containsKey(varName)) {
                return mi.var_types.get(varName);
            }
        }

        String lookupClassName = currentClass;
        while (lookupClassName != null) {
            ClassInfo current_ci = symbolTable.get(lookupClassName);
            if (current_ci == null) {

                break;
            }

            if (current_ci.fields != null && current_ci.fields.containsKey(varName)) {
                return current_ci.fields.get(varName);
            }
            lookupClassName = current_ci.parent;
        }

        return null;
    }

    private List<String> getMethodParamTypes(Object methodInfoObj) {
        List<String> res = new ArrayList<>();
        if (methodInfoObj == null)
            return res;

        String[] candidateFieldNames = new String[] {
                "paramTypes", "params", "parameters", "formalTypes", "argTypes",
                "parameterTypes", "formals", "param_type_list", "parameter_list", "param_names"
        };

        for (String fname : candidateFieldNames) {
            try {
                Field f = methodInfoObj.getClass().getDeclaredField(fname);
                f.setAccessible(true);
                Object v = f.get(methodInfoObj);
                if (v == null)
                    continue;
                if (v instanceof List) {
                    for (Object o : (List<?>) v)
                        res.add((String) o);
                    return res;
                }
                if (v instanceof Map) {

                    for (Object val : ((Map<?, ?>) v).values())
                        res.add((String) val);
                    return res;
                }
                if (v instanceof String[]) {
                    for (String s : (String[]) v)
                        res.add(s);
                    return res;
                }

                if (v instanceof String) {
                    String s = ((String) v).trim();
                    if (s.length() > 0) {
                        if (s.contains(",")) {
                            for (String part : s.split(","))
                                res.add(part.trim());
                        } else {

                            res.add(s);
                        }
                        return res;
                    }
                }
            } catch (NoSuchFieldException | IllegalAccessException ignored) {

            } catch (ClassCastException ignored) {

            }
        }

        return res;
    }

    public TypeCheckerVisitor(HashMap<String, ClassInfo> symbolTable) {
        this.symbolTable = symbolTable;
    }

    public R visit(NodeList n, A argu) {

        R _ret = null;

        int _count = 0;

        for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {

            e.nextElement().accept(this, argu);

            _count++;

        }

        return _ret;

    }

    public R visit(NodeListOptional n, A argu) {

        if (n.present()) {

            R _ret = null;

            int _count = 0;

            for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {

                e.nextElement().accept(this, argu);

                _count++;

            }

            return _ret;

        }

        else

            return null;

    }

    public R visit(NodeOptional n, A argu) {

        if (n.present())

            return n.node.accept(this, argu);

        else

            return null;

    }

    public R visit(NodeSequence n, A argu) {

        R _ret = null;

        int _count = 0;

        for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {

            e.nextElement().accept(this, argu);

            _count++;

        }

        return _ret;

    }

    public R visit(NodeToken n, A argu) {
        return null;
    }

    /**
     * * f0 -> ( ImportFunction() )?
     * * f1 -> MainClass()
     * * f2 -> ( TypeDeclaration() )*
     * * f3 -> <EOF>
     */

    public R visit(Goal n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        n.f2.accept(this, argu);

        n.f3.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> "import"
     * * f1 -> "java.util.function.Function"
     * * f2 -> ";"
     */

    public R visit(ImportFunction n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        n.f2.accept(this, argu);
        lambdaActive = true;

        return _ret;

    }

    /**
     * * f0 -> "class"
     * * f1 -> Identifier()
     * * f2 -> "{"
     * * f3 -> "public"
     * * f4 -> "static"
     * * f5 -> "void"
     * * f6 -> "main"
     * * f7 -> "("
     * * f8 -> "String"
     * * f9 -> "["
     * * f10 -> "]"
     * * f11 -> Identifier()
     * * f12 -> ")"
     * * f13 -> "{"
     * * f14 -> PrintStatement()
     * * f15 -> "}"
     * * f16 -> "}"
     */

    public R visit(MainClass n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        currentClass = n.f1.f0.tokenImage;

        n.f1.accept(this, argu);

        n.f2.accept(this, argu);

        n.f3.accept(this, argu);

        n.f4.accept(this, argu);

        n.f5.accept(this, argu);

        currentMethod = "main";
        n.f6.accept(this, argu);

        n.f7.accept(this, argu);

        n.f8.accept(this, argu);

        n.f9.accept(this, argu);

        n.f10.accept(this, argu);

        n.f11.accept(this, argu);

        n.f12.accept(this, argu);

        n.f13.accept(this, argu);

        n.f14.accept(this, argu);

        n.f15.accept(this, argu);

        n.f16.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> ClassDeclaration()
     * * | ClassExtendsDeclaration()
     */

    public R visit(TypeDeclaration n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> "class"
     * * f1 -> Identifier()
     * * f2 -> "{"
     * * f3 -> ( VarDeclaration() )*
     * * f4 -> ( MethodDeclaration() )*
     * * f5 -> "}"
     */

    public R visit(ClassDeclaration n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        currentClass = n.f1.f0.tokenImage;
        // System.out.println(currentClass);

        n.f1.accept(this, argu);

        n.f2.accept(this, argu);

        n.f3.accept(this, argu);

        n.f4.accept(this, argu);

        n.f5.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> "class"
     * * f1 -> Identifier()
     * * f2 -> "extends"
     * * f3 -> Identifier()
     * * f4 -> "{"
     * * f5 -> ( VarDeclaration() )*
     * * f6 -> ( MethodDeclaration() )*
     * * f7 -> "}"
     */

    public R visit(ClassExtendsDeclaration n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        currentClass = n.f1.f0.tokenImage;

        n.f1.accept(this, argu);

        n.f2.accept(this, argu);
        String parentclass = n.f3.f0.tokenImage;
        if (!symbolTable.containsKey(parentclass)) {
            System.out.println("Type error");
            System.exit(0);
        }
        n.f3.accept(this, argu);

        n.f4.accept(this, argu);

        n.f5.accept(this, argu);

        n.f6.accept(this, argu);

        n.f7.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> Type()
     * * f1 -> Identifier()
     * * f2 -> ";"
     */

    public R visit(VarDeclaration n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        n.f2.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> "public"
     * * f1 -> Type()
     * * f2 -> Identifier()
     * * f3 -> "("
     * * f4 -> ( FormalParameterList() )?
     * * f5 -> ")"
     * * f6 -> "{"
     * * f7 -> ( VarDeclaration() )*
     * * f8 -> ( Statement() )*
     * * f9 -> "return"
     * * f10 -> Expression()
     * * f11 -> ";"
     * * f12 -> "}"
     */

    public R visit(MethodDeclaration n, A argu) {
        R _ret = null;
        currentMethod = n.f2.f0.tokenImage;
        n.f0.accept(this, argu);
        n.f1.accept(this, argu);

        String methodName = currentMethod;
        ClassInfo ci = symbolTable.get(currentClass);
        if (ci == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (ci.methods == null || !ci.methods.containsKey(methodName)) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        String methodtype = ci.methods.get(methodName).returnType;

        n.f2.accept(this, argu);
        n.f3.accept(this, argu);
        n.f4.accept(this, argu);
        n.f5.accept(this, argu);
        n.f6.accept(this, argu);
        n.f7.accept(this, argu);
        n.f8.accept(this, argu);
        n.f9.accept(this, argu);

        String prevExpected = expectedFunctionalType;
        if (parseFunctionType(methodtype) != null) {
            expectedFunctionalType = methodtype;
        } else {
            expectedFunctionalType = null;
        }

        _ret = n.f10.accept(this, argu);
        expectedFunctionalType = prevExpected;

        String exprToken = (String) _ret;
        if (exprToken == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        String expr_type = resolveTypeToken(exprToken);
        if (expr_type == null) {
            // System.out.println(exprToken);
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if (!is_equal(expr_type, methodtype)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f11.accept(this, argu);
        n.f12.accept(this, argu);

        return _ret;
    }

    /**
     * * f0 -> FormalParameter()
     * * f1 -> ( FormalParameterRest() )*
     */

    public R visit(FormalParameterList n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> Type()
     * * f1 -> Identifier()
     */

    public R visit(FormalParameter n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> ","
     * * f1 -> FormalParameter()
     */

    public R visit(FormalParameterRest n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> ArrayType()
     * * | BooleanType()
     * * | IntegerType()
     * * | Identifier()
     * * | LambdaType()
     */

    public R visit(Type n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> "int"
     * * f1 -> "["
     * * f2 -> "]"
     */

    public R visit(ArrayType n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        n.f2.accept(this, argu);

        return (R) "int[]";

    }

    /**
     * * f0 -> "boolean"
     */

    public R visit(BooleanType n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        return (R) "boolean";

    }

    /**
     * * f0 -> "int"
     */

    public R visit(IntegerType n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        return (R) "int";

    }

    /**
     * f0 -> "Function"
     * f1 -> "<"
     * f2 -> Identifier()
     * f3 -> ","
     * f4 -> Identifier()
     * f5 -> ">"
     */
    public R visit(LambdaType n, A argu) {
        R _ret = null;

        n.f0.accept(this, argu);
        if (!lambdaActive) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f1.accept(this, argu); // <

        String type1 = n.f2.f0.tokenImage;
        if (!("Integer".equals(type1) || "Boolean".equals(type1) || symbolTable.containsKey(type1))) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        n.f2.accept(this, argu);

        n.f3.accept(this, argu); // ,

        String type2 = n.f4.f0.tokenImage;
        if (!("Integer".equals(type2) || "Boolean".equals(type2) || symbolTable.containsKey(type2))) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        n.f4.accept(this, argu);

        n.f5.accept(this, argu);

        return _ret;
    }

    /**
     * * f0 -> Block()
     * * | AssignmentStatement()
     * * | ArrayAssignmentStatement()
     * * | IfStatement()
     * * | WhileStatement()
     * * | PrintStatement()
     */

    public R visit(Statement n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> "{"
     * * f1 -> ( Statement() )*
     * * f2 -> "}"
     */

    public R visit(Block n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        n.f2.accept(this, argu);

        return _ret;

    }

    /**
     * f0 -> Identifier()
     * f1 -> "="
     * f2 -> Expression()
     * f3 -> ";"
     */
    public R visit(AssignmentStatement n, A argu) {

        String var_name = n.f0.f0.tokenImage;
        String var_type = lookupVarType(var_name);

        if (var_type == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        LambdaExpression lamNode = extractLambda(n.f2);

        if (lamNode != null) {

            String[] parts = parseFunctionType(var_type);

            if (parts == null) {
                System.out.println("Symbol not found");
                System.exit(0);
            }

            String expectedParamType = parts[0];
            String expectedReturnType = parts[1];

            String paramName = lamNode.f1.f0.tokenImage;
            MethodInfo mi = symbolTable.get(currentClass).methods.get(currentMethod);

            String old = mi.var_types.get(paramName);
            mi.var_types.put(paramName, expectedParamType);
            R bodyR = lamNode.f4.accept(this, argu);
            String resolvedBodyType = resolveTypeToken((String) bodyR);

            if (old == null)
                mi.var_types.remove(paramName);
            else
                mi.var_types.put(paramName, old);

            if (resolvedBodyType == null) {
                System.out.println("Symbol not found");
                System.exit(0);
            }
            if (!is_equal(resolvedBodyType, expectedReturnType)) {
                System.out.println("Type error");
                System.exit(0);
            }
        } else {

            R rhsResult = n.f2.accept(this, argu);
            String resolvedRhsType = resolveTypeToken((String) rhsResult);

            if (resolvedRhsType == null) {
                System.out.println("Symbol not found");
                System.exit(0);
            }

            if (!is_equal(resolvedRhsType, var_type)) {
                System.out.println("Type error");
                System.exit(0);
            }
        }

        return null;
    }

    /**
     * f0 -> Identifier()
     * f1 -> "["
     * f2 -> Expression()
     * f3 -> "]"
     * f4 -> "="
     * f5 -> Expression()
     * f6 -> ";"
     */
    public R visit(ArrayAssignmentStatement n, A argu) {

        String arrayName = n.f0.f0.tokenImage;
        String arrayType = lookupVarType(arrayName);

        if (arrayType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!arrayType.endsWith("[]")) {
            System.out.println("Type error");
            System.exit(0);
        }

        R indexResult = n.f2.accept(this, argu);
        if (indexResult.equals("<<FUNCTION>>")) {
            System.out.println("Type error");
            System.exit(0);
        }
        String indexType = resolveTypeToken((String) indexResult);
        // System.out.println(indexResult);
        if (indexType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(indexType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        R rhsResult = n.f5.accept(this, argu);
        if (rhsResult.equals("<<FUNCTION>>")) {
            System.out.println("Type error");
            System.exit(0);
        }
        String rhsType = resolveTypeToken((String) rhsResult);

        if (rhsType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        String expectedElementType = arrayType.substring(0, arrayType.length() - 2);

        if (!is_equal(rhsType, expectedElementType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return null;
    }

    /**
     * * f0 -> IfthenElseStatement()
     * * | IfthenStatement()
     */

    public R visit(IfStatement n, A argu) {

        R _ret = null;
        // System.out.println("HI");

        n.f0.accept(this, argu);

        return _ret;

    }

    /**
     * f0 -> "if"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> Statement()
     */
    public R visit(IfthenStatement n, A argu) {

        R condResult = n.f2.accept(this, argu);
        if (condResult.equals("<<FUNCTION>>")) {
            System.out.println("Type error");
            System.exit(0);
        }

        String condType = resolveTypeToken((String) condResult);

        if (condType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if (!"boolean".equals(condType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f4.accept(this, argu);

        return null;
    }

    /**
     * * f0 -> "if"
     * * f1 -> "("
     * * f2 -> Expression()
     * * f3 -> ")"
     * * f4 -> Statement()
     * * f5 -> "else"
     * * f6 -> Statement()
     */

    public R visit(IfthenElseStatement n, A argu) {

        R _ret = null;
        // System.out.println("HI");
        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        R condResult = n.f2.accept(this, argu);

        if (condResult.equals("<<FUNCTION>>")) {
            System.out.println("Type error");
            System.exit(0);
        }
        String condType = resolveTypeToken((String) condResult);

        if (condType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if (!"boolean".equals(condType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f3.accept(this, argu);

        n.f4.accept(this, argu);

        n.f5.accept(this, argu);

        n.f6.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> "while"
     * * f1 -> "("
     * * f2 -> Expression()
     * * f3 -> ")"
     * * f4 -> Statement()
     */

    public R visit(WhileStatement n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        R condResult = n.f2.accept(this, argu);
        if (condResult.equals("<<FUNCTION>>")) {
            System.out.println("Type error");
            System.exit(0);
        }
        String condType = resolveTypeToken((String) condResult);

        if (condType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if (!"boolean".equals(condType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f3.accept(this, argu);

        n.f4.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> "System.out.println"
     * * f1 -> "("
     * * f2 -> Expression()
     * * f3 -> ")"
     * * f4 -> ";"
     */

    public R visit(PrintStatement n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        R condResult = n.f2.accept(this, argu);
        if (condResult.equals("<<FUNCTION>>")) {
            System.out.println("Type error");
            System.exit(0);
        }
        String condType = resolveTypeToken((String) condResult);

        if (condType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if (!"int".equals(condType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f3.accept(this, argu);

        n.f4.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> OrExpression()
     * * | AndExpression()
     * * | CompareExpression()
     * * | neqExpression()
     * * | AddExpression()
     * * | MinusExpression()
     * * | TimesExpression()
     * * | DivExpression()
     * * | ArrayLookup()
     * * | ArrayLength()
     * * | MessageSend()
     * * | LambdaExpression()
     * * | PrimaryExpression()
     */

    public R visit(Expression n, A argu) {

        R _ret = null;

        _ret = n.f0.accept(this, argu);
        // System.out.println(_ret);
        return _ret;

    }

    /**
     * * f0 -> "("
     * * f1 -> Identifier()
     * * f2 -> ")"
     * * f3 -> "->"
     * * f4 -> Expression()
     */

    /**
     * f0 -> "("
     * f1 -> Identifier()
     * f2 -> ")"
     * f3 -> "->"
     * f4 -> Expression()
     */
    public R visit(LambdaExpression n, A argu) {
        String paramName = n.f1.f0.tokenImage;

        if (lookupVarType(paramName) != null) {
            System.out.println("Type error");
            System.exit(0);
        }

        if (expectedFunctionalType != null) {

            String[] parts = parseFunctionType(expectedFunctionalType);
            if (parts == null) {

                System.out.println("Symbol not found");
                System.exit(0);
            }
            String expectedParamType = parts[0];
            String expectedBodyRetType = parts[1];

            MethodInfo mi = symbolTable.get(currentClass).methods.get(currentMethod);
            String old = mi.var_types.get(paramName);
            mi.var_types.put(paramName, expectedParamType);

            String bodyType = (String) n.f4.accept(this, argu);
            if (bodyType.equals("<<FUNCTION>>")) {
                System.out.println("Type error");
                System.exit(0);
            }
            String resolvedBodyType = resolveTypeToken(bodyType);

            if (old == null) {
                mi.var_types.remove(paramName);
            } else {
                mi.var_types.put(paramName, old);
            }

            if (resolvedBodyType == null) {
                System.out.println("Symbol not found");
                System.exit(0);
            }

            if (!is_equal(resolvedBodyType, expectedBodyRetType)) {
                System.out.println("Type error");
                System.exit(0);
            }

            return (R) expectedFunctionalType;

        } else {

            return (R) "<<FUNCTION>>";
        }
    }

    /**
     * * f0 -> PrimaryExpression()
     * * f1 -> "&&"
     * * f2 -> PrimaryExpression()
     */

    public R visit(AndExpression n, A argu) {
        R _ret = null;

        R leftR = n.f0.accept(this, argu);
        String leftToken = (String) leftR;
        String leftType = resolveTypeToken(leftToken);
        if (leftType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"boolean".equals(leftType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f1.accept(this, argu);

        R rightR = n.f2.accept(this, argu);
        String rightToken = (String) rightR;
        String rightType = resolveTypeToken(rightToken);
        if (rightType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"boolean".equals(rightType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "boolean";
    }

    public R visit(OrExpression n, A argu) {
        R _ret = null;

        R leftR = n.f0.accept(this, argu);
        String leftToken = (String) leftR;
        String leftType = resolveTypeToken(leftToken);
        if (leftType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"boolean".equals(leftType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f1.accept(this, argu);

        R rightR = n.f2.accept(this, argu);
        String rightToken = (String) rightR;
        String rightType = resolveTypeToken(rightToken);
        if (rightType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"boolean".equals(rightType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "boolean";
    }

    public R visit(CompareExpression n, A argu) {
        R _ret = null;

        R leftR = n.f0.accept(this, argu);
        String leftToken = (String) leftR;
        String leftType = resolveTypeToken(leftToken);
        if (leftType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        n.f1.accept(this, argu);

        R rightR = n.f2.accept(this, argu);
        String rightToken = (String) rightR;
        String rightType = resolveTypeToken(rightToken);
        if (rightType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if (!"int".equals(leftType) || !"int".equals(rightType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "boolean";
    }

    public R visit(neqExpression n, A argu) {
        R _ret = null;

        R leftR = n.f0.accept(this, argu);
        String leftToken = (String) leftR;
        String leftType = resolveTypeToken(leftToken);
        if (leftType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        n.f1.accept(this, argu);

        R rightR = n.f2.accept(this, argu);
        String rightToken = (String) rightR;
        String rightType = resolveTypeToken(rightToken);
        if (rightType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if (!is_equal(leftType, rightType) && !is_equal(rightType, leftType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "boolean";
    }

    public R visit(AddExpression n, A argu) {
        R _ret = null;

        R leftR = n.f0.accept(this, argu);
        String leftToken = (String) leftR;
        String leftType = resolveTypeToken(leftToken);
        if (leftType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(leftType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f1.accept(this, argu);

        R rightR = n.f2.accept(this, argu);
        String rightToken = (String) rightR;
        String rightType = resolveTypeToken(rightToken);
        if (rightType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(rightType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "int";
    }

    public R visit(MinusExpression n, A argu) {
        R _ret = null;

        R leftR = n.f0.accept(this, argu);
        String leftToken = (String) leftR;
        String leftType = resolveTypeToken(leftToken);
        if (leftType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(leftType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f1.accept(this, argu);

        R rightR = n.f2.accept(this, argu);
        String rightToken = (String) rightR;
        String rightType = resolveTypeToken(rightToken);
        if (rightType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(rightType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "int";
    }

    public R visit(TimesExpression n, A argu) {
        R _ret = null;

        R leftR = n.f0.accept(this, argu);
        String leftToken = (String) leftR;
        String leftType = resolveTypeToken(leftToken);
        if (leftType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(leftType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f1.accept(this, argu);

        R rightR = n.f2.accept(this, argu);
        String rightToken = (String) rightR;
        String rightType = resolveTypeToken(rightToken);
        if (rightType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(rightType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "int";
    }

    public R visit(DivExpression n, A argu) {
        R _ret = null;

        R leftR = n.f0.accept(this, argu);
        String leftToken = (String) leftR;
        String leftType = resolveTypeToken(leftToken);
        if (leftType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(leftType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f1.accept(this, argu);

        R rightR = n.f2.accept(this, argu);
        String rightToken = (String) rightR;
        String rightType = resolveTypeToken(rightToken);
        if (rightType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(rightType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "int";
    }

    public R visit(ArrayLookup n, A argu) {
        R _ret = null;

        R arrR = n.f0.accept(this, argu);
        String arrToken = (String) arrR;
        String arrType = resolveTypeToken(arrToken);
        if (arrType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!arrType.endsWith("[]")) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f1.accept(this, argu);

        R idxR = n.f2.accept(this, argu);
        String idxToken = (String) idxR;
        String idxType = resolveTypeToken(idxToken);
        if (idxType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }
        if (!"int".equals(idxType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f3.accept(this, argu);

        String elemType = arrType.substring(0, arrType.length() - 2);
        return (R) elemType;
    }

    /**
     * * f0 -> PrimaryExpression()
     * * f1 -> "."
     * * f2 -> "length"
     */

    public R visit(ArrayLength n, A argu) {
        R _ret = null;

        R arrTypeR = n.f0.accept(this, argu);
        String arrTypeToken = (String) arrTypeR;

        String resolvedArrType = resolveTypeToken(arrTypeToken);
        if (resolvedArrType == null) {
            System.out.println("Type error");
            System.exit(0);
        }

        if (!resolvedArrType.endsWith("[]")) {
            System.out.println("Type error");
            System.exit(0);
        }

        n.f1.accept(this, argu);
        n.f2.accept(this, argu);

        return (R) "int";
    }

    public R visit(MessageSend n, A argu) {

        String receiverToken = (String) n.f0.accept(this, argu);
        String methodName = n.f2.f0.tokenImage;
        List<Expression> argExprNodes = new ArrayList<>();
        if (n.f4.present()) {
            ExpressionList el = (ExpressionList) n.f4.node;
            argExprNodes.add(el.f0);
            for (Enumeration<Node> e = el.f1.elements(); e.hasMoreElements();) {
                argExprNodes.add(((ExpressionRest) e.nextElement()).f1);
            }
        }

        String resolvedReceiverType = resolveTypeToken(receiverToken);
        if (resolvedReceiverType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if ("int".equals(resolvedReceiverType) || "boolean".equals(resolvedReceiverType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        if ("int[]".equals(resolvedReceiverType) || "boolean[]".equals(resolvedReceiverType)) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        String[] funPartsReceiver = parseFunctionType(resolvedReceiverType);
        if (funPartsReceiver != null) {
            if (!"apply".equals(methodName)) {
                System.out.println("Type error");
                System.exit(0);
            }
            if (argExprNodes.size() != 1) {
                System.out.println("Type error");
                System.exit(0);
            }

            String expectedArgType = normalizeType(funPartsReceiver[0]);
            String expectedRetType = normalizeType(funPartsReceiver[1]);
            Expression argExpr = argExprNodes.get(0);

            LambdaExpression lamNode = extractLambda(argExpr);
            if (lamNode != null) {

                checkLambdaArgument(lamNode, expectedArgType, argu);
            } else {

                R argTypeR = argExpr.accept(this, argu);
                String resolvedArgType = resolveTypeToken((String) argTypeR);
                if (resolvedArgType == null) {
                    System.out.println("Symbol not found");
                    System.exit(0);
                }
                if (!is_equal(resolvedArgType, expectedArgType)) {
                    System.out.println("Type error");
                    System.exit(0);
                }
            }
            return (R) expectedRetType;
        }

        MethodInfo methodInfoObj = lookupMethodInfo(resolvedReceiverType, methodName);
        if (methodInfoObj == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        List<String> paramTypes = getMethodParamTypes(methodInfoObj);
        if (paramTypes.size() != argExprNodes.size()) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        for (int i = 0; i < paramTypes.size(); ++i) {
            String expectedType = normalizeType(paramTypes.get(i));
            Expression argExpr = argExprNodes.get(i);

            LambdaExpression argLam = extractLambda(argExpr);
            if (argLam != null) {

                checkLambdaArgument(argLam, expectedType, argu);
            } else {

                R argTypeR = argExpr.accept(this, argu);
                String resolvedArgType = resolveTypeToken((String) argTypeR);
                if (resolvedArgType == null) {
                    System.out.println("Symbol not found");
                    System.exit(0);
                }
                if (!is_equal(resolvedArgType, expectedType)) {
                    System.out.println("Type error");
                    System.exit(0);
                }
            }
        }

        return (R) normalizeType(methodInfoObj.returnType);
    }

    /**
     * * f0 -> Expression()
     * * f1 -> ( ExpressionRest() )*
     */

    public R visit(ExpressionList n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> ","
     * * f1 -> Expression()
     */

    public R visit(ExpressionRest n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        n.f1.accept(this, argu);

        return _ret;

    }

    /**
     * * f0 -> IntegerLiteral()
     * * | TrueLiteral()
     * * | FalseLiteral()
     * * | Identifier()
     * * | ThisExpression()
     * * | ArrayAllocationExpression()
     * * | AllocationExpression()
     * * | NotExpression()
     * * | BracketExpression()
     */

    public R visit(PrimaryExpression n, A argu) {
        R _ret = null;

        _ret = n.f0.accept(this, argu);
        // System.out.println(_ret);
        return _ret;

    }

    /**
     * * f0 -> <INTEGER_LITERAL>
     */

    public R visit(IntegerLiteral n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        return (R) "int";

    }

    /**
     * * f0 -> "true"
     */

    public R visit(TrueLiteral n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        return (R) "boolean";

    }

    /**
     * * f0 -> "false"
     */

    public R visit(FalseLiteral n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        return (R) "boolean";

    }

    /**
     * * f0 -> <IDENTIFIER>
     */

    public R visit(Identifier n, A argu) {

        R _ret = null;
        String name = n.f0.tokenImage;
        // System.out.println(name);
        n.f0.accept(this, argu);

        return (R) name;

    }

    /**
     * * f0 -> "this"
     */

    public R visit(ThisExpression n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);

        return (R) "this";

    }

    /**
     * f0 -> "new"
     * f1 -> "int"
     * f2 -> "["
     * f3 -> Expression()
     * f4 -> "]"
     */
    public R visit(ArrayAllocationExpression n, A argu) {

        R sizeExprResult = n.f3.accept(this, argu);
        if (sizeExprResult.equals("<<FUNCTION>>")) {
            System.out.println("Type error");
            System.exit(0);
        }

        String sizeExprType = resolveTypeToken((String) sizeExprResult);

        if (sizeExprType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if (!"int".equals(sizeExprType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "int[]";
    }

    /**
     * * f0 -> "new"
     * * f1 -> Identifier()
     * * f2 -> "("
     * * f3 -> ")"
     */
    public R visit(AllocationExpression n, A argu) {

        String className = (String) n.f1.accept(this, argu);
        // System.out.println(className);
        if (!this.symbolTable.containsKey(className)) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        return (R) className;
    }

    /**
     * * f0 -> "!"
     * * f1 -> Expression()
     */

    /**
     * f0 -> "!"
     * f1 -> Expression()
     */
    public R visit(NotExpression n, A argu) {

        R exprResult = n.f1.accept(this, argu);
        if (exprResult.equals("<<FUNCTION>>")) {
            System.out.println("Type error");
            System.exit(0);
        }

        String exprType = resolveTypeToken((String) exprResult);

        if (exprType == null) {
            System.out.println("Symbol not found");
            System.exit(0);
        }

        if (!"boolean".equals(exprType)) {
            System.out.println("Type error");
            System.exit(0);
        }

        return (R) "boolean";
    }

    /**
     * * f0 -> "("
     * * f1 -> Expression()
     * * f2 -> ")"
     */

    public R visit(BracketExpression n, A argu) {

        R _ret = null;

        n.f0.accept(this, argu);
        // System.out.println("HI");
        _ret = n.f1.accept(this, argu);
        // System.out.println(_ret);
        n.f2.accept(this, argu);

        return _ret;

    }

}